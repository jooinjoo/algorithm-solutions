# 숨바꼭질 5

> https://www.acmicpc.net/problem/17071

## 문제 설명

- 문제

수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 500,000)에 있고, 동생은 점 K(0 ≤ K ≤ 500,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의
위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다. 동생은 항상 걷기만 한다. 동생은 항상 매 초마다 이동을 하며, 이동은
가속이 붙는다. 동생이 이동하는 거리는 이전에 이동한 거리보다 1을 더한 만큼 이동한다. 즉, 동생의 처음 위치는 K, 1초가 지난 후 위치는 K+1, 2초가 지난 후 위치는 K+1+2, 3초가 지난 후의 위치는
K+1+2+3이다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오. 동생을 찾는 위치는 정수 좌표이어야 하고, 수빈이가 0보다 작은 좌표로, 50만보다
큰 좌표로 이동하는 것은 불가능하다.

- 입력

첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.

- 출력

수빈이가 동생을 찾는 가장 빠른 시간을 출력한다. 수빈이가 동생을 찾을 수 없거나, 찾는 위치가 500,000을 넘는 경우에는 -1을 출력한다.

## 접근 방법

동생이 수빈과 함께 매 초마다 이동하기 때문에, 매 초마다 둘의 위치를 비교하며 만날 수 있는지 검증한다.  
둘이 만날 수 있는 조건은 1) 둘이 동시에 한 지점에 도착하거나, 2) 수빈이 홀수/짝수 번째 초에 도착한 지점을 동생이 이후에 같은 홀수/짝수 번째 초에 도착하면 된다.    
따라서 수빈의 방문 처리를 홀/짝으로 나눈 2차원 배열에 대해 BFS 탐색하며, 가장 빠른 시간을 출력.

## 문제 해결 과정

- 첫 번째 시도:
    - 동생의 위치를 K = K + (시간 * (시간 + 1) / 2)로 도출하여, 큐에서 꺼낸 위치가 동생 위치와 같으면 해당 시간을 출력했지만 실패.
        - 수빈의 방문 처리를 오로지 1차원 배열에 하면서, 수빈이 한번 간 지점을 재방문 할 수 없어 2) 조건을 만족시킬 수 없었다.
        - 예를 들어, 수빈이 4초에 8 위치에 도착하고, 동생은 6초에 8 위치에 도착한다고 가정.
            - 그렇다면 수빈은 5초에 9, 6초에 8로 돌아오면서 왔다 갔다 하는 반복으로 동생을 만날 수 있다. 이는 6초, 8초 ... 모두 해당.
            - 반면 수빈이 4초에 8, 동생은 5초에 8에 도착하면 서로 엇갈리면서 만날 수 없게 된다.
- 최종 해결 방법:
    - 동생의 현재 위치가 매 초에 의해 바뀌므로, 매 초는 즉 BFS의 단계를 의미. 따라서 `int lev`에 시간을 담음.
    - 또한 홀/짝 시간의 여부에 따라 방문 처리를 해야 하므로 `int vis[2][500001]`에 (홀/짝 시간, 좌표)를 담는다. 0은 짝수, 1은 홀수 의미.
    - `(n == k)`에 대해 조기 종료 조건 설정.
    - 매 초마다 동생 위치 `k += lev`를 갱신한 뒤, `if (vis[lev % 2][k] > 0)`를 통해 현재 동생 위치가 수빈이 같은 홀/짝 시간대에 방문한 위치인지 확인.
        - 만약 방문했다면 수빈이 그 위치에 도착했을 때부터 동생이 올 때까지 앞뒤 반복만 하면 되므로 만날 수 있어 `flag = true`. 2) 조건 성립
    - 동생이 현재 단계에 만나지 못했다면, 직전 단계에서 삽입한 모든 수빈의 위치 큐 다음 노드로 이동.
        - `int size = q.size()`만큼만 `q.poll()`하며 새로운 삽입 노드는 뽑지 않도록 설정.
        - 만약 뽑은 수빈의 위치에서 다음 노드에 방문 가능하다면, 직전 시간에서 현재 시간 대에 방문 가능하다는
          뜻이므로 `vis[lev % 2][nr] = vis[(lev + 1) % 2][cur] + 1`.
            - 한편 수빈의 다음 위치 `int nr`이 동생의 현재 위치 `k`와 같다면, 현재 시간에 둘이 동시에 이동하여 만날 수 있으므로 1) 조건 성립. 종료.
            - 만나지 못했다면 큐에 다음 노드를 삽입한 뒤, 모든 노드 삽입이 끝나면 시간 1 증가.
    - `flag` 여부에 따라 결과 출력.
- 25.8.11. 다시 푼 방법:
    - 수빈과 동생이 만나는 방법엔 두 가지가 존재.
      1) 동시에 둘이 같은 지점으로 이동하여 만남.
      2) 수빈이 이미 도착했던 지점을 동생이 이후에 도착하고, 그 시간이 동일한 홀/짝일 때.
    - 따라서 수빈의 방문 경로를 2차원 배열 `int[2][500001] dp`로 설정하여, 짝수 시간 방문 시 `int[0][]`, 홀수일 시 `int[1][]`에 걸린 시간을 저장.
    - 우선 각 초마다 동생의 위치를 먼저 이동시킨다. 이 과정에서 범위를 벗어나면 종료.
        - 한편 새로운 `K`에 따라 이미 수빈이 방문한 지점이면 만날 수 있으므로 종료. 위의 2) 조건 성립.
    - 다음으로 수빈이 이동하는데, 직전 시간에서 큐에 삽입한 크기만큼만 큐에서 꺼낸다.
        - 이 과정에서 1) 조건이 성립하면 종료.

## 다시 푼 코드

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;

public class Solution {

    static int N, K;
    static int[][] dp;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] tok = br.readLine().split(" ");
        N = Integer.parseInt(tok[0]);
        K = Integer.parseInt(tok[1]);

        if (N == K) {
            System.out.println(0);
            return;
        }

        dp = new int[2][500001];
        dp[0][N] = 1;

        Queue<Integer> que = new LinkedList<>();
        que.offer(N);
        boolean flag = false;
        int lev = 0;
        while (!que.isEmpty()) {
            // 동생 이동
            lev++;
            K += lev;
            if (K > 500000) break;
            if (dp[lev % 2][K] > 0) {
                flag = true;
                break;
            }

            // 수빈 이동
            int size = que.size();
            for (int i = 0; i < size; i++) {
                int cur = que.poll();
                int[] d = {1, -1, cur};
                for (int j = 0; j < 3; j++) {
                    int next = cur + d[j];
                    if (next < 0 || next > 500000 || dp[lev % 2][next] != 0) continue;
                    dp[lev % 2][next] = dp[(lev + 1) % 2][cur] + 1;
                    if (next == K) {
                        flag = true;
                        break;
                    }
                    que.offer(next);
                }
                if (flag) break;
            }
            if (flag) break;
        }

        System.out.println(flag ? lev : -1);
    }
}
```