# 숨바꼭질 5

> https://www.acmicpc.net/problem/17071

## 문제 설명

- 문제

수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 500,000)에 있고, 동생은 점 K(0 ≤ K ≤ 500,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의
위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다. 동생은 항상 걷기만 한다. 동생은 항상 매 초마다 이동을 하며, 이동은
가속이 붙는다. 동생이 이동하는 거리는 이전에 이동한 거리보다 1을 더한 만큼 이동한다. 즉, 동생의 처음 위치는 K, 1초가 지난 후 위치는 K+1, 2초가 지난 후 위치는 K+1+2, 3초가 지난 후의 위치는
K+1+2+3이다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오. 동생을 찾는 위치는 정수 좌표이어야 하고, 수빈이가 0보다 작은 좌표로, 50만보다
큰 좌표로 이동하는 것은 불가능하다.

- 입력

첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.

- 출력

수빈이가 동생을 찾는 가장 빠른 시간을 출력한다. 수빈이가 동생을 찾을 수 없거나, 찾는 위치가 500,000을 넘는 경우에는 -1을 출력한다.

## 접근 방법

동생이 수빈과 함께 매 초마다 이동하기 때문에, 매 초마다 둘의 위치를 비교하며 만날 수 있는지 검증한다.  
둘이 만날 수 있는 조건은 1) 둘이 동시에 한 지점에 도착하거나, 2) 수빈이 홀수/짝수 번째 초에 도착한 지점을 동생이 이후에 같은 홀수/짝수 번째 초에 도착하면 된다.    
따라서 수빈의 방문 처리를 홀/짝으로 나눈 2차원 배열에 대해 BFS 탐색하며, 가장 빠른 시간을 출력.

## 문제 해결 과정

- 첫 번째 시도:
    - 동생의 위치를 K = K + (시간 * (시간 + 1) / 2)로 도출하여, 큐에서 꺼낸 위치가 동생 위치와 같으면 해당 시간을 출력했지만 실패.
        - 수빈의 방문 처리를 오로지 1차원 배열에 하면서, 수빈이 한번 간 지점을 재방문 할 수 없어 2) 조건을 만족시킬 수 없었다.
        - 예를 들어, 수빈이 4초에 8 위치에 도착하고, 동생은 6초에 8 위치에 도착한다고 가정.
            - 그렇다면 수빈은 5초에 9, 6초에 8로 돌아오면서 왔다 갔다 하는 반복으로 동생을 만날 수 있다. 이는 6초, 8초 ... 모두 해당.
            - 반면 수빈이 4초에 8, 동생은 5초에 8에 도착하면 서로 엇갈리면서 만날 수 없게 된다.
- 최종 해결 방법:
    - 동생의 현재 위치가 매 초에 의해 바뀌므로, 매 초는 즉 BFS의 단계를 의미. 따라서 `int lev`에 시간을 담음.
    - 또한 홀/짝 시간의 여부에 따라 방문 처리를 해야 하므로 `int vis[2][500001]`에 (홀/짝 시간, 좌표)를 담는다. 0은 짝수, 1은 홀수 의미.
    - `(n == k)`에 대해 조기 종료 조건 설정.
    - 매 초마다 동생 위치 `k += lev`를 갱신한 뒤, `if (vis[lev % 2][k] > 0)`를 통해 현재 동생 위치가 수빈이 같은 홀/짝 시간대에 방문한 위치인지 확인.
        - 만약 방문했다면 수빈이 그 위치에 도착했을 때부터 동생이 올 때까지 앞뒤 반복만 하면 되므로 만날 수 있어 `flag = true`. 2) 조건 성립
    - 동생이 현재 단계에 만나지 못했다면, 직전 단계에서 삽입한 모든 수빈의 위치 큐 다음 노드로 이동.
        - `int size = q.size()`만큼만 `q.poll()`하며 새로운 삽입 노드는 뽑지 않도록 설정.
        - 만약 뽑은 수빈의 위치에서 다음 노드에 방문 가능하다면, 직전 시간에서 현재 시간 대에 방문 가능하다는
          뜻이므로 `vis[lev % 2][nr] = vis[(lev + 1) % 2][cur] + 1`.
            - 한편 수빈의 다음 위치 `int nr`이 동생의 현재 위치 `k`와 같다면, 현재 시간에 둘이 동시에 이동하여 만날 수 있으므로 1) 조건 성립. 종료.
            - 만나지 못했다면 큐에 다음 노드를 삽입한 뒤, 모든 노드 삽입이 끝나면 시간 1 증가.
    - `flag` 여부에 따라 결과 출력.
