# 뮤탈리스크

> https://www.acmicpc.net/problem/12869

## 문제 설명

- 문제

수빈이는 강호와 함께 스타크래프트 게임을 하고 있다. 수빈이는 뮤탈리스크 1개가 남아있고, 강호는 SCV N개가 남아있다.

각각의 SCV는 남아있는 체력이 주어져있으며, 뮤탈리스크를 공격할 수는 없다. 즉, 이 게임은 수빈이가 이겼다는 것이다.

뮤탈리스크가 공격을 할 때, 한 번에 세 개의 SCV를 공격할 수 있다.

첫 번째로 공격받는 SCV는 체력 9를 잃는다.
두 번째로 공격받는 SCV는 체력 3을 잃는다.
세 번째로 공격받는 SCV는 체력 1을 잃는다.
SCV의 체력이 0 또는 그 이하가 되어버리면, SCV는 그 즉시 파괴된다. 한 번의 공격에서 같은 SCV를 여러 번 공격할 수는 없다.

남아있는 SCV의 체력이 주어졌을 때, 모든 SCV를 파괴하기 위해 공격해야 하는 횟수의 최솟값을 구하는 프로그램을 작성하시오.

- 입력

첫째 줄에 SCV의 수 N (1 ≤ N ≤ 3)이 주어진다. 둘째 줄에는 SCV N개의 체력이 주어진다. 체력은 60보다 작거나 같은 자연수이다.

- 출력

첫째 줄에 모든 SCV를 파괴하기 위한 공격 횟수의 최솟값을 출력한다.

## 접근 방법

세 SCV 각각의 체력을 3차원 배열의 인덱스 값이라고 간주하면, 세 체력이 모두 0이 될 때는 (0, 0, 0)이라고 볼 수 있다.  
따라서 각각의 첫 체력이 최대 인덱스 값이며, BFS 탐색을 통해 뺄 수 있는 모든 경우의 수를 빼며 방문 처리 한다.  
이 과정에서 (0, 0, 0)에 도착한다면, 방문 처리하며 가장 빨리 도착한 경우이므로 지금까지의 방문 누적값을 출력.  
최대 체력은 60이므로 (60^3)의 시간 복잡도, 약 22만의 경우의 수.

## 문제 해결 과정

- 첫 번째 시도:
    - N에 따라 나올 수 있는 모든 순열 조합을 저장한 뒤, BFS 탐색하며 각각의 순열 조합을 현재 체력값에 빼주며 루프.
        - 아이디어 자체는 맞았지만, 특정 자료구조에 방문 처리를 하지 않다보니 메모리 초과로 실패.
- 최종 해결 방법:
    - 최대 3개의 SCV이므로, 뺄 수 있는 순열의 모든 조합을 미리 `int[][] sub`에 저장.
        - SCV가 1 또는 2인 경우에 9 또는 6부터 빼지 않는 경우가 있어 잘못됐지만, 시간 복잡도로 보나 정답 도출로 보나 상관 없음.
    - 최대 체력은 60이므로, `vis = new int[61][61][61]`에 최초 체력부터 방문 처리 시작.
        - 예를 들어, (12, 10, 4)의 경우 `vis[12][10][4] = 1`.
        - 이후 `sub[5] = {9, 3, 1}`을 빼면  `vis[3][7][3] = 2` 이런 식으로 갱신된다.
            - 한편 `sub`의 원소를 빼던 도중 배열의 인덱스가 0 미만으로 떨어지면 안되기 때문에 `Math.max(0, cur[0] - sub[i][0])`으로 조정.
    - 이미 값이 있는 경우는 방문 처리한 케이스기 때문에 건너 뛴다.
    - 이 과정에서 모든 인덱스의 값이 0이 되는 순간 종료.
    - 3차원 배열에 대한 방문 처리는 생각치 못해 시간이 오래 걸렸다. 반드시 2차원 배열만 방문 처리한다는 생각을 버리자. 